#!/usr/bin/env python3
import argparse
import gzip
import os
import socket
import sys
import json
import requests
import atexit
from dnslib import DNSRecord, DNSHeader, RR, A
from ip2geotools.errors import LimitExceededError
import threading

COUNT_UPPER = 10
IP2LOCATION_API_URL = (
    "https://api.ip2location.io/?key=2F77EA52BF5A243428D1D33C03AEAA57&ip={}&format=json"
)
IP_API_URL = "http://ip-api.com/json/{}"
locations = """[
    {
        "ip_address": "45.33.55.171",
        "city": "Fremont",
        "region": "California",
        "country": "US",
        "latitude": 37.5482697,
        "longitude": -121.988571
    },
    {
        "ip_address": "170.187.142.220",
        "city": "Atlanta",
        "region": "Georgia",
        "country": "US",
        "latitude": 33.7489924,
        "longitude": -84.3902644
    },
    {
        "ip_address": "213.168.249.157",
        "city": "London",
        "region": "England",
        "country": "GB",
        "latitude": 51.4893335,
        "longitude": -0.14405508452768728
    },
    {
        "ip_address": "139.162.82.207",
        "city": "Shibuya",
        "region": "Tokyo",
        "country": "JP",
        "latitude": 35.6645956,
        "longitude": 139.6987107
    },
    {
        "ip_address": "45.79.124.209",
        "city": "Mumbai",
        "region": "Maharashtra",
        "country": "IN",
        "latitude": 19.0785451,
        "longitude": 72.878176
    },
    {
        "ip_address": "192.53.123.145",
        "city": "Toronto",
        "region": "Ontario",
        "country": "CA",
        "latitude": 43.6534817,
        "longitude": -79.3839347
    },
    {
        "ip_address": "192.46.221.203",
        "city": "Sydney",
        "region": "New South Wales",
        "country": "AU",
        "latitude": -33.8698439,
        "longitude": 151.2082848
    }
  ]
"""


class Location:
    def __init__(self, ip, latitude, longitude, load=0):
        self.ip_address = ip
        self.latitude = latitude
        self.longitude = longitude
        self.load = load


class Dns_server:
    def __init__(self, port, name):
        self.cache_file = "dns_cache.json"
        self.cache = {}
        self.last_location = -1
        self.count = 0
        self.load_cache()
        atexit.register(self.write_to_file)
        self.index = 0
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(("", port))
        if not name.endswith("."):
            name += "."
        self.name = name
        self.servers = []
        value = json.loads(locations)

        for entry in value:
            x = Location(
                entry["ip_address"],
                entry["latitude"],
                entry["longitude"],
            )
            self.servers.append(x)

    def write_to_file(self):
        with open(self.cache_file, "w") as f:
            json.dump(self.cache, f)

    def load_cache(self):
        if os.path.exists(self.cache_file):
            with open(self.cache_file, "r") as f:
                self.cache = json.load(f)
            print(self.cache)

    def get_location_from_ip(self, ip):
        try:
            response = requests.get(IP2LOCATION_API_URL.format(ip))
            if response.status_code == 200:
                data = response.json()
                latitude = None
                longitude = None
                for key, value in data.items():
                    if key.startswith("lat"):
                        latitude = value
                    elif key.startswith("lon"):
                        longitude = value
                    if latitude and longitude:
                        break
                self.cache[ip] = (latitude, longitude)
                return (latitude, longitude)
            else:
                sys.stderr.write(
                    f"Failed to retrieve location for IP {ip}. Status code: {response.status_code}\n"
                )
                return None
        except Exception as e:
            sys.stderr.write(
                f"An error occurred while fetching location for IP {ip}: {e}\n"
            )
            return None

    def get_closest_location(self, client_ip):
        temp = []
        if client_ip in self.cache:
            client_location = self.cache.get(client_ip)
            print("get from cache")
            print(client_location)
        else:
            try:
                client_location = self.get_location_from_ip(client_ip)
                print(f"get from lookup api {client_location}")
            except LimitExceededError:
                sys.stderr.write(f"No more try to look up the location {client_ip}\n")
                return None
        if client_location is None:
            return None
        for i in range(len(self.servers)):
            distance_lat = abs(client_location[0] - self.servers[i].latitude)
            distance_lon = abs(client_location[1] - self.servers[i].longitude)
            distance = distance_lat + distance_lon  # Sum of absolute differences
            new_entry = (distance, i)
            temp.append(new_entry)
        temp = sorted(temp, key=lambda x: x[0])
        print(temp)
        for each in temp:
            if self.servers[each[1]].load <= 0.8:
                print(f"the location is index of {each[1]}")
                if self.last_location == each[1]:
                    self.count += 1
                if self.count > COUNT_UPPER:
                    self.count = 0
                    continue
                self.last_location = each[1]
                return self.servers[each[1]]

        sys.stderr.write(f"Failed to retrieve client location for IP {client_ip}\n")
        return None

    def check_index_range(self):
        if self.index >= len(self.servers):
            self.index = 0
        if self.index < 0:
            self.index = 0

    def handle_request(self, data, addr):
        request = DNSRecord.parse(data)
        qname = str(request.q.qname)
        qtype = request.q.qtype
        print(f"Qname: {qname}\nGet request: {request}")
        if (
            qname == self.name and qtype == 1
        ):  # Check if it's an A query for the specified name
            closest = self.get_closest_location(addr[0])
            if not closest:
                print("fail to look up geo location of ip!")
                self.check_index_range()
                closest = self.servers[self.index]
                self.index += 1
            response = DNSRecord(
                DNSHeader(id=request.header.id, qr=1, aa=1, ra=1), q=request.q
            )
            response.add_answer(RR(qname, rdata=A(closest.ip_address)))
            self.socket.sendto(response.pack(), addr)

    def run(self):
        print("DNS Server is running...")
        while True:
            data, addr = self.socket.recvfrom(1024)
            threading.Thread(target=self.handle_request, args=(data, addr)).start()


def main():
    parser = argparse.ArgumentParser(description="DNS Server")
    parser.add_argument(
        "-n",
        dest="name",
        default="cs5700cdn.example.com.",
        type=str,
        help="CDN-specific name",
    )
    parser.add_argument(
        "-p",
        dest="port",
        type=int,
        default=20210,
        help="Port number for the DNS server",
    )
    args = parser.parse_args()

    dns_server = Dns_server(args.port, args.name)
    dns_server.run()


if __name__ == "__main__":
    main()
