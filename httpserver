#!/usr/bin/env python3
from http.server import BaseHTTPRequestHandler, HTTPServer
import time
import sys 
import requests
import gzip
import argparse
import hashlib
import os

# origin server to for cdn 
# http://cs5700cdnorigin.ccs.neu.edu:8080/. 

# Size limit for the cache is 20MB (20 * 1024 * 1024 bytes)
CACHE_SIZE = 1024 * 1024

hostname = "localhost"
port = 8080

class LFUCache:
    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {} # map path to filename
        self.frequencyMap = [] # keep an sorted array of [path, frequency]
        self.current_size = 0
    
    def get_safe_filename(self, path):
        # Generate a filesystem-safe filename by hashing the key.
        return hashlib.sha256(path.encode()).hexdigest()
        
    def get(self, path):
        if path not in self.cache:
            return -1 
        else:
            filename = self.cache[path]
            cache_dir = "./cache"
            file_path = f"{cache_dir}/{filename}"
            try:
                with open(file_path, 'rb') as f:
                    content = f.read()
                self.updateFrequency_list(path)
                return gzip.decompress(content).decode('utf-8')
            except (FileNotFoundError, OSError) as e:
                print(f"Error reading file {filename}: {e}")
                return -1

    def put(self, path, content):
        if path in self.cache:
            raise ValueError("Key already exists in cache")
        
        file_size = sys.getsizeof(path) + sys.getsizeof(gzip.compress(content.encode('utf-8')))
        
        while self.cache and self.current_size + file_size > self.capacity:
            print("#############################")
            print("Cache is full, Evicting the least frequently used item")
            print("file size: ", file_size)
            print("Current size + file size: ", self.current_size + file_size)
            print("Cache size: ", self.capacity)
            print("#############################")
            self.evict()
        
        self.cache[path] = self.get_safe_filename(path)
        self.write_to_file(path, content)
        
        # update the current size with real file size
        file_size = os.path.getsize(f"./cache/{self.cache[path]}")
        
        self.current_size += file_size
        print("#############################")
        print(f"Current Cache Size Used: {self.current_size / CACHE_SIZE * 100:.2f} %")
        print("#############################")
        self.frequencyMap.append([path, 1])
        self.frequencyMap.sort(key=lambda x: x[1])
    
    def write_to_file(self, path, content):
        file_name = self.get_safe_filename(path)
        cache_dir = "./cache"
        file_path = f"{cache_dir}/{file_name}"
        
        try:
            os.makedirs(cache_dir, exist_ok=True)  # Ensure the cache directory exists
            file_content = gzip.compress(content.encode('utf-8'))
            with open(file_path, 'wb') as f:
                f.write(file_content)
        except OSError as e:
            print(f"Failed to write file {file_path}: {e}")
    
          
    def updateFrequency_list(self, key):
        # find the path in the frequency list
        for each in self.frequencyMap:
            if each[0] == key:
                each[1] += 1
                #sort the frequency list
                self.frequencyMap.sort(key=lambda x: x[1])
                print("#############################")
                print("Frequency list updated")
                print("FrequencyMap: ", self.frequencyMap)
                print("#############################")
                    
    def evict(self):
        print(f"Current Cache Size Used: {self.current_size / CACHE_SIZE * 100:.2f} %")
        
        # remove the least recently used item from the frequency list
        for each in self.frequencyMap:
            # check the frequency from the beginning and see if it's in the cache
            if each[0] in self.cache:
                # remove the file from the filesystem
                file_name = self.cache[each[0]]
                file_path = f"./cache/{file_name}"
                file_size = 0
                try:
                    file_size = os.path.getsize(file_path)
                    os.remove(file_path)
                except FileNotFoundError:
                    print("File not found")
                    continue
                    
                self.current_size -= file_size
                
                # remove the item from the cache
                del self.cache[each[0]]
                
                break
        
LFUcache = LFUCache(CACHE_SIZE)

class MyHTTPServer(HTTPServer):
    def __init__(self, server_address, handler_class, origin):
        self.origin = origin
        super().__init__(server_address, handler_class)
       
class MyHandler(BaseHTTPRequestHandler):

    def do_GET(self):  
        global LFUcache
        print("Requesting for: ", self.path)
        # if the path is in the cache, return the content
        response_content = LFUcache.get(self.path)
        if response_content != -1:
            # response_content = LFUcache.get(self.path)
            print("######## Cache Hit!!!! ########")
            
        # if the path is not in the cache, fetch from origin server
        else:
            print("######## Cache miss!!!! ########")
            # fetch from origin server
            response_content = self.fetch_from_origin_server(self.path)
            if not response_content:
                self.send_response(404)
                self.send_header("Content-type", "text/html")
                self.end_headers()
                self.wfile.write(b"404 Not Found")
                return
           
            LFUcache.put(self.path, response_content)
            print("Add to cache successful")
            print("Current Cache Size: ", LFUcache.current_size)
        
        print("GET request received")
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.end_headers()
        self.wfile.write(response_content.encode('utf-8'))
          
    def fetch_from_origin_server(self, path):
        origin_url = f"{self.server.origin}{path}"
    
        print("Fetching from origin server")
        try: 
            response = requests.get(origin_url)
            response.raise_for_status()
            content = response.content.decode('utf-8')
            return content
        except requests.exceptions.HTTPError as err:
            print(f"Error: {err}")
            return None 
        
def run(server_class=MyHTTPServer, handler_class=MyHandler, port=8080, origin =""):
    server_address = ('', port)
    httpd = server_class(server_address, handler_class, origin)
    print(f'Starting httpd on port {port}...')
    httpd.serve_forever()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="HTTP CDN Server")
    parser.add_argument('-p', '--port', type=int, help='Port number the HTTP server binds to', required=True)
    parser.add_argument('-o', '--origin', type=str, help='Origin server URL for the CDN', required=True)

    args = parser.parse_args()

    run(port=args.port, origin=args.origin)
                                    